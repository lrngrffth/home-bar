import * as types from 'notion-types';
import { Block, ExtendedRecordMap, PageMap } from 'notion-types';
export { default as isUrl } from 'is-url-superb';

type EstimatePageReadTimeOptions = {
    wordsPerMinute?: number;
    imageReadTimeInSeconds?: number;
};
type ContentStats = {
    numWords: number;
    numImages: number;
};
type PageReadTimeEstimate = ContentStats & {
    totalWordsReadTimeInMinutes: number;
    totalImageReadTimeInMinutes: number;
    totalReadTimeInMinutes: number;
};
/**
 * Returns an estimate for the time it would take for a person to read the content
 * in the given Notion page.
 *
 * Uses Medium for inspiration.
 *
 * @see https://blog.medium.com/read-time-and-you-bc2048ab620c
 * @see https://github.com/ngryman/reading-time
 *
 * TODO: handle non-english content.
 */
declare function estimatePageReadTime(block: Block, recordMap: ExtendedRecordMap, { wordsPerMinute, imageReadTimeInSeconds }?: EstimatePageReadTimeOptions): PageReadTimeEstimate;
/**
 * Same as `estimatePageReadTime`, except it returns the total time estimate as
 * a human-readable string.
 *
 * For example, "9 minutes" or "less than a minute".
 */
declare function estimatePageReadTimeAsHumanizedString(block: Block, recordMap: ExtendedRecordMap, opts: EstimatePageReadTimeOptions): string;

declare const formatDate: (input: string | number, { month }?: {
    month?: "long" | "short";
}) => string;

interface NotionDateTime {
    type: 'datetime';
    start_date: string;
    start_time?: string;
    time_zone?: string;
}
declare const formatNotionDateTime: (datetime: NotionDateTime) => string;

/**
 * Performs a traversal over a given Notion workspace starting from a seed page.
 *
 * Returns a map containing all of the pages that are reachable from the seed
 * page in the space.
 *
 * If `rootSpaceId` is not defined, the space ID of the root page will be used
 * to scope traversal.
 *
 *
 * @param rootPageId - Page ID to start from.
 * @param rootSpaceId - Space ID to scope traversal.
 * @param getPage - Function used to fetch a single page.
 * @param opts - Optional config
 */
declare function getAllPagesInSpace(rootPageId: string, rootSpaceId: string | undefined, getPage: (pageId: string) => Promise<ExtendedRecordMap>, { concurrency, traverseCollections, targetPageId }?: {
    concurrency?: number;
    traverseCollections?: boolean;
    targetPageId?: string;
}): Promise<PageMap>;

declare function getBlockCollectionId(block: Block, recordMap: ExtendedRecordMap): string | null;

declare function getBlockIcon(block: Block, recordMap: ExtendedRecordMap): string | null | undefined;

/**
 * Returns the parent page block containing a given page.
 *
 * Note that many times this will not be the direct parent block since
 * some non-page content blocks can contain sub-blocks.
 */
declare const getBlockParentPage: (block: types.Block, recordMap: types.ExtendedRecordMap, { inclusive }?: {
    inclusive?: boolean;
}) => types.PageBlock | null;

declare function getBlockTitle(block: Block, recordMap: ExtendedRecordMap): string;

/**
 * Gets the canonical, display-friendly version of a page's ID for use in URLs.
 */
declare const getCanonicalPageId: (pageId: string, recordMap: ExtendedRecordMap, { uuid }?: {
    uuid?: boolean;
}) => string | null;

/**
 * Attempts to find a valid date from a given property.
 */
declare const getDateValue: (prop: any[]) => types.FormattedDate | null;

declare const getPageBreadcrumbs: (recordMap: types.ExtendedRecordMap, activePageId: string) => Array<any> | null;

/**
 * Gets the IDs of all blocks contained on a page starting from a root block ID.
 */
declare const getPageContentBlockIds: (recordMap: types.ExtendedRecordMap, blockId?: string) => string[];

/**
 * Gets URLs of all images contained on the given page.
 */
declare const getPageImageUrls: (recordMap: types.ExtendedRecordMap, { mapImageUrl }: {
    mapImageUrl: (url: string, block: types.Block) => string | null;
}) => string[];

/**
 * Gets the value of a collection property for a given page (collection item).
 *
 * @param propertyName property name
 * @param block Page block, often be first block in blockMap
 * @param recordMap
 * @returns - The return value types will follow the following principles:
 *  1. if property is date type, it will return `number` or `number[]`(depends on `End Date` switch)
 *  2. property is text-like will return `string`
 *  3. multi select property will return `string[]`
 *  4. checkbox property return `boolean`
 * @todo complete all no-text property type
 */
declare function getPageProperty<T = string | number | boolean | string[] | number[]>(propertyName: string, block: Block, recordMap: ExtendedRecordMap): T;

interface TableOfContentsEntry {
    id: types.ID;
    type: types.BlockType;
    text: string;
    indentLevel: number;
}
/**
 * Gets the metadata for a table of contents block by parsing the page's
 * H1, H2, and H3 elements.
 */
declare const getPageTableOfContents: (page: types.PageBlock, recordMap: types.ExtendedRecordMap) => Array<TableOfContentsEntry>;

declare function getPageTitle(recordMap: ExtendedRecordMap): string | null;

/**
 * Gets the IDs of all tweets embedded on a page.
 */
declare const getPageTweetIds: (recordMap: types.ExtendedRecordMap) => string[];

/**
 * Gets the URLs of all tweets embedded on a page.
 */
declare const getPageTweetUrls: (recordMap: types.ExtendedRecordMap) => string[];

/**
 * Gets the raw, unformatted text content of a block's content value.
 *
 * This is useful, for instance, for extracting a block's `title` without any
 * rich text formatting.
 */
declare const getTextContent: (text?: types.Decoration[]) => string;

declare const idToUuid: (id?: string) => string;

declare const defaultMapImageUrl: (url: string | undefined, block: Block) => string | undefined;

declare const defaultMapPageUrl: (rootPageId?: string) => (pageId: string) => string;

declare function mergeRecordMaps(recordMapA: ExtendedRecordMap, recordMapB: ExtendedRecordMap): ExtendedRecordMap;

declare const normalizeTitle: (title?: string | null) => string;

declare const normalizeUrl: (url?: string) => string;

/**
 * Robustly extracts the notion page ID from a notion URL or pathname suffix.
 *
 * Defaults to returning a UUID (with dashes).
 */
declare const parsePageId: (id?: string | null, { uuid }?: {
    uuid?: boolean;
}) => string | null | undefined;

declare const uuidToId: (uuid: string) => string;

export { type NotionDateTime, type TableOfContentsEntry, defaultMapImageUrl, defaultMapPageUrl, estimatePageReadTime, estimatePageReadTimeAsHumanizedString, formatDate, formatNotionDateTime, getAllPagesInSpace, getBlockCollectionId, getBlockIcon, getBlockParentPage, getBlockTitle, getCanonicalPageId, getDateValue, getPageBreadcrumbs, getPageContentBlockIds, getPageImageUrls, getPageProperty, getPageTableOfContents, getPageTitle, getPageTweetIds, getPageTweetUrls, getTextContent, idToUuid, mergeRecordMaps, normalizeTitle, normalizeUrl, parsePageId, uuidToId };
